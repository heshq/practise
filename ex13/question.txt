从这道题开始，主要锻炼你的接口设计和c++惯用写法。

这道题目的背景是，团队需要开发一个trace平台（类似于GL的bugbase），基于mysql数据库，提供自定义条件搜索和定期自动整理功能。
要求你提供一个c++的sql拼装工具，满足：
调用方式简洁直观，调用这个拼装器的代码可读性高
传入必要的参数后，生成合法的sql命令字符串（返回std::string的形式）
既能方便地编码固定的sql命令，也便于动态生成（例如用户自定义搜索的功能，搜索条件的数量和种类不确定）
支持int、float、string三种字段数据类型
支持关键字：select、update、insert、delete、where、order by、asc、desc
作为一个通用库工具，你的拼装器要尽可能少限制用户的调用方式，兼容用户不太严谨的调用参数

提供怎样的类、模板、函数，全都由你自己决定。你的拼装器本身的复杂度和可读性是次要的，首要目标是让用户调用你的拼装器的代码尽可能简洁直观。


完整的参考答案里，除了实现前面给你的接口，还演示了：
利用运算符重载实现专用语法（DSL）
利用多重继承与模版方法简化实现
利用显式实例化实现模版的声明与定义分离（模版声明在头文件里，定义在源文件里）
利用模版的声明与定义的分离，实现了对用户调用模版参数的限制
下面照例再追加几个问题：
上面列举的第4条，对用户使用的模版参数进行限制，具体来说是有哪些限制？
参考答案里Select、Update、Delete都分别申明了两个where方法。一个直接传入Factor的普通方法，另一个是通过三个参数自己创建Factor的方法模版。试把它们统一成一个模版方法。
参考答案的头文件把不希望用户直接使用的类和函数放在了名字空间_query_maker_inner里面。这里可不可以用更简单的名字，比如 _inner ？
参考答案的头文件引用了标准头文件map和vector，而用户代码不一定需要这些。请修改参考答案，使用户在调用query_maker时，不会意外地引入这些头文件。