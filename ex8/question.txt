之前出的几个搜索问题，都比较简单直接。但在更多的问题里，一些试图缩减搜索状态树的方法，其本身复杂度会抵消掉状态树减少所带来的优化。
数独就是这样一种问题。即使有序地避免掉所有重复局面，搜索求解高难度的数独题还是比较慢的。如果假如一些辅助的数据结构，帮助搜索算法避开一部分明确不合理的尝试，理论上可以优化算法速度。
为了确定一种优化是否对大部分数独题目有效，而不是只对部分题目较快其他题目反而更慢，就需要你用大量不同题目进行性能测试。
为了确定不同优化之间组合后效果是更好还是更差，就需要你的代码能够在编译期或运行期对不同的优化进行开关控制。

要求：完成一个解数独程序，并比较直接搜索和几种不同的优化之间的性能差别，找到一个比较好的优化组合。







首先是吐槽：
数独拼错了！！！Sudoku是数独的意思，而Sodoku是一种病！！拼写错误绝对零容忍！！不要等你面对几百个源文件，而且里面的命名被IDE的rename搞乱了才长记性！
用文件管理你的测试用例！！！测你的程序每次都要手工填数组好烦的有木有！！熟练以后文件IO两分钟就能写好。不要等到你面对几百个源文件，编译一次半个小时，然后调试两步就发现需要换一组数据了才长记性！
不要滥用引用参数。传引用参数实际上是传指针，这个操作跟传一个字长以内的数据没有差别，反而函数内每次使用都需要解引用，因此实际上性能更差。又而且引用参数会限制调用方的实参为左值，在你的程序里这个限制毫无意义。
Grid这个类的命名很误导人，明明是EmptyGrid嘛。
声明引用和指针时，"&"和"*"最好贴着变量名。
详细解释一下最后一个吐槽。
C语言的声明语法实际上是： [类型] [解引用表达式]{,[解引用表达式]}...。
比如： int a[]，表示a[*]这样解引用后，得到的是一个int const类型的数据。
再比如： int const *a, b; 表示*a和b，都是int const；并不是说a和b，都是int const *类型。
C++的引用声明语法，沿用了这一规则。所以声明引用时，如果把'&'或'*'与名字分开，会错误地暗示成后一种理解。

参考答案见附件，你的程序比我给出的最朴素的算法快了一倍，但比我的最优算法慢了一倍。这个对比希望你能自己验证一下，然后分析原因。

patch:
比如： int a[]，表示a[*]这样解引用后，得到的是一个int const类型的数据。
-->
比如： int a[]，表示a[*]这样解引用后，得到的是一个int类型的数据。