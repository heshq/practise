题目9按一天一题，周末算一天的节奏，应该是周一出给你，周二交答案的。算你生病推迟一天的话，也应该在周三交答案。
快速排序是个基础到不能再基础的算法，你多半应该是会写。就算不会，伪代码在《算法导论》上写得非常清楚，网上搜一下也很容易找到。
算法的主要思路是，从数组里选出一个数X，用O(n)的复杂度把所有比X大的数挪到X的一边，其他的挪到另一边，其中n是数组长度。然后从X的位置把数组一分为二，对两段分别递归地重复上一个步骤。
容易发现递归的每一层，数组分割出的每个小段，它们长度的和仍然是数组的总长度n。因此递归的每层上，上面所说的处理的总复杂度都是O(n)。那么最终排序的总复杂度就取决于算法递归了多少层。最好的情况是，每次分割都尽可能平均，那么经过 log2(n) 次分割后，，于是递归的层数是O(lg n)，总复杂度是O(n*lg n)。最坏的情况是，每次都恰好取了当前范围内最大的一个数作为X，而划分出来的递归段落长度是 n-1 ，重复下去需要递归n层，于是复杂度就变成 O(N^2) 了。
理论上来说，任何一种在O(n)时间内选取划分数X的算法，都不能避免上面的最坏情况出现。更复杂的划分数选取算法，本身就会影响快速排序整体的复杂度。

这里不需要你解决快排算法劣化的问题，而是考虑一下算法劣化会发生什么。递归如果要进行n层，意味着占用n层系统栈，这就不光是排序有可能很慢的问题了，而是基础算法导致程序崩溃的问题了。这就是glibc才用非递归算法实现标准库的qsort函数的原因，用函数内部维护的栈，而不是占用n层系统栈。
请你实现一个快速排序函数，然后参考题目8参考答案里的非递归算法，自己改出一个非递归的快速排序函数。

进一步思考：glibc的快速排序不但通过非递归避免了爆栈，还实现了O(1)的空间复杂度，也就是说占用的空间不随数组尺寸变化，避免了爆内存。这是怎样做到的？