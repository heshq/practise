上次的接口设计问题练习了C++风格的DSL，接下来再练习一下old-school的DSL。
c标准库内的printf()系列函数，用格式化字符串的形式提供了一种字符串生成DSL，不但使调用代码的可读性很高，在一些特殊的场景（比如国际化/本地化）远比c++的iostream好用。
但作为c库函数，sprintf()函数需要事先准备好足够尺寸的缓冲区才能正常工作。
现在请你实现一个函数或类，用于拼装字符串，要求既具有sprintf()的优点，又不需要用户关心缓冲区的分配。


参考答案提供了一种比较偷懒的做法来满足题目要求。虽然代码量很少，但下面这些点是希望你从中学到的：
c标准库的异常处理。
new异常的c风格处理（通过std::nothrow参数，让new在异常时返回NULL，而不是抛出bad_alloc异常）。
通过goto为函数实现多重出口，要注意每个出口上进行了哪些资源释放以及每次跳转时各资源的状态。这里利用goto避免了一些重复的错误处理代码，简化了整个函数，所有跳转的方向也是相同的。但如果你在使用goto时发现函数内跳转交错不清，就应该考虑不用goto改用其他方式实现。
变参函数。


虽然满足了题目要求，参考答案还是有很多缺陷的：

不能调整插入参数的顺序，这会给国际化造成一定限制
不能检查参数数量，可能会导致段错误
不能检查参数类型，参考答案里注释掉的一行就会出问题。测试一下这行代码输出的结果，尝试着解释一下为什么输出这些东西？
对"%s"的处理可能导致死循环
学习一下boost库里的format类，看看它是怎样解决上述每个问题的。

另外，这种基于字符串的DSL，在各种工具库里非常常见，因为各种语言都可以实现它。

比如unix下经典的命令行参数处理函数getopt：http://en.wikipedia.org/wiki/Getopt