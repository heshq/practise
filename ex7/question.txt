分时操作系统内，cpu的运算能力会被分割为一个个时间片。进程调度器会在每个时间片结束后，从等待运行的进程中选择一个，在下一个时间片内运行它。
调度器选择进程的基本思路分为两部分：动态优先级 和 优先级队列。
优先级队列是一个数据结构，或者说数据容器。它像普通队列一样，可以不断推入进程数据（pid和优先级）。但数据出队的顺序，由优先级和入队顺序共同决定：优先级越高的先出队，优先级相同的先进先出。
调度器会根据进程的静态优先级（也叫固有优先级，由父进程、root、进程本身和用户共同决定），以及进程运行的情况（运行比较频繁的进程会降低优先级，以确保低优先的进程也有机会运行），不断调整进程的动态优先级，并将它推入优先级队列。
现在要你实现一个优先级队列，提供接口：
void push( PID id, PSTATE state, unsigned priority);  // 向队列中推入状态为state，动态优先级为priority的进程id
bool has( PID id); // 判断进程id是否已在队列中
void set_ready( PID id); // 改变进程id的状态为P_READY
PID pop(); // 返回队列内，状态为P_READY的进程中，优先级最高的进程中，最先入队的进程的id
其中，PID为尺寸不定的无符号整型，priority为0~99之间的整数，PSTATE为枚举：
enum PSTATE {
  P_READY, P_RUNNING, P_BLOCK, P_SLEEP
};

可以假设：
不会push已经进入队列的进程、状态为P_RUNNING的进程
已经保存在队列中的进程，不会退出、不会改变动态优先级
入队的进程，状态只可能由非P_READY转变为P_READY
可以假定PID上限为PID_MAX，也就是说进程总数不超过PID_MAX
可以借用标准库内的任何工具
需求：
各接口方法的时间复杂度尽可能小，特别是push()和pop()
队列实现尽可能不依赖于PID_MAX，也就是说理论上最好能容纳无限个进程
需要附带单元测试，或者简易的交互式手工测试程序


PS 实在没有思路的话，可以看一下《算法导论》里讲“heap”的章节，然后实在自己实现不出来堆的话，可以借用一下标准库<algorithm>里的*_heap()系列算法。



严谨地说，优先级相同的进程，并不是以入队先后决定出队先后的，而是以READY的先后顺序决定出队顺序。
也就是说，如果一个进程入队后，一直不是READY状态的话，等到它READY了，也必须等比它先READY的同优先级进程先执行过才会轮到它。
进程不能通过sleep或者block来“憋”优先顺序，而是在它READY之后，再尽量减少它的等待时间。

这是最终patch了（但愿），放心地做吧。