各种数据类型各有用处，这里你用int的话，就可能出现截断。用float的话，因为float和int虽然一样长，但是float的位里有部分被指数位占用，所以float实际上不能存储任意int值。比如如果这里用float，a*3+b的值就会算错。话说你的代码里a*3+b哪去了？
不只是基本类型有自己的运算规则，自定义类型也可以有。 template< typename T, typename T2, unsigned N> Vec< T, N> operator*( T2 number, Vec< T, N> const &vec) 这样的方式来实现运算符，不但能一口通吃所有基本类型运算，还能兼容有相应运算的自定义类型。
再考虑一个问题，如果有一个自定义类型A，定义了加减乘除运算，但没有定义它与ostream的operator<<运算，能否把这个类型A套用到参考答案的Vec模版里组成向量？

考虑到题目一的完成速度，题目二还是简单一点吧。这次的题目只是让你熟悉一下基本的运算符重载、函数重载，和一点点简单的模版应用。

数学上的向量是由标量组成的一个N维有序数组：
A = (a1,a2,...,aN)
其中标量可以理解为一般意义上的数，有序表示各维度的标量不能交换顺序，N是大于零的整数。
基于向量的定义，有如下计算：
向量加减法：A,B均N维向量, A+B = (a1,...,aN) + (b1, ..., bN) = ( a1 + b1, ..., aN + bN)，减法类似。
向量与实数乘除法： A为N维向量，B为实数， A * B = (a1, ..., aN) * B = ( a1 * B, ..., aN * B)，除法类似。
向量加法和减法，向量与实数的乘法，都满足交换律。
题目要求是，实现一个向量类Vec，确保：
Vec对象的维数是确定的，一个Vec对象构建之后，就不能与维数不同的数组进行计算或赋值
对于4维Vec对象a、b、c，下面这段代码：
a[ 0] = 2;
a[ 1] = 4;
a[ 2] = 6;
a[ 4] = 5592402;
b[ 0] = 5;
b[ 1] = 7;
b[ 2] = 9;
b[ 3] = 11;
c = a * 3 + b;
std::cout << std::fixed;
std::cout << 0.5 * a << std::endl;
std::cout << c << std::endl;

的输出应类似于：

(1,2,3,2796201)
(11,19,27,16777217)
完成上面的Vec类后，进一步考虑：
在进行计算和赋值时，如果对参与的Vec对象检查维度是否匹配，一方面加入了额外的判断，另一方面真发现不匹配后还需要一堆错误/异常处理。有没有办法避免这两个缺点？
Vec对象中的每个标量，应该用整型还是浮点型保存？如果用浮点型保存，会有什么问题？如果用整型保存，用一个浮点数乘它应该怎样计算？
上面代码里面，给Vec对象a和b赋值的方式弱爆了。有没有更好的方式？比如说像数组初始化一样？
operator*() 运算，可以放在Vec类内实现，也可以放在Vec类外。哪种方法更好？
operator+=() 运算，应该返回什么？（这个primer上似乎讲了）